#!/usr/bin/env python
#####################
#
# production_list
#
# Generates lists of production or
# processed data (full RAT format or
# ntuples) for download.
#
# Author: Matt Mottram
#         <m.mottram@sussex.ac.uk>
#
#####################

import os
import sys
import database
import grid
try:
    import argparse
except:
    raise ImportError("argparse not available; python version needs to be 2.7+")
try:
    import json
except:
    raise ImportError("json not available; python version needs to be 2.7+")
    

# Copy type will be set to SURL if lcg-utils or gfal are not available
copy_type = "GUID"
server_list = []


def get_module_list_version(data_type, rat_version=None):
    """Get a list of available modules.
    """
    rows = database.view("_design/proddata/_view/%s_by_mod_pass_sr" % (data_type),
                    reduce=True, group=True, group_level=2)
    module_list = []
    for row in rows:
        if rat_version and row["key"][1]!=unicode(rat_version):
            continue
        module_list.append(row["key"][0])
    return module_list


def get_module_list_label(data_type, label=None):
    """Get a list of available modules.                                                                                                            
    """
    rows = database.view("_design/proddata/_view/%s_by_label" % (data_type),
                   reduce=True, group=True, group_level=2)
    module_list = []
    for row in rows:
        if label and row["key"][0]!=unicode(label):
            continue
        module_list.append(row["key"][1])
    return module_list


def get_list_by_module_version(data_type, module, rat_version, run_range):
    """Get a list of files for the settings given.
    """
    names = []
    sizes = []
    guids = []
    adlers = []
    rows = database.view("_design/proddata/_view/%s_by_mod_pass_sr" % (data_type),
                   startkey = [module, rat_version],
                   endkey = [module, rat_version+"_"],
                   reduce=False)
    for row in rows:
        if copy_type=="GUID":
            if not row["value"][2] or row["value"][2]=="":
                print "Cannot get file %s, no GUID" % (row["value"][0])
                continue
        else:
            if len(row["value"][4])==0 or row["value"][4]=="":
                print "Cannot get file %s, no SURL" % row["value"][0]
                continue
        # Run range is after pass in the key, have to filter here rather than on server
        if run_range:
            if row["key"][3] < run_range[0] or row["key"][3] > run_range[1]:
                continue
        names.append(row["value"][0])
        sizes.append(row["value"][1])
        if copy_type=="GUID":
            guids.append(row["value"][2])
        else:
            guids.append(grid.get_closest_copy(server_list, row["value"][4]))
        adlers.append(row["value"][5])
    return names, sizes, guids, adlers


def get_list_by_label_module(data_type, label, module, run_range):
    """Get a list of files for the settings given

    If no module give, return all modules.
    """
    names = []
    sizes = []
    guids = []
    adlers = []
    startkey = [label, module]
    endkey = [label, module+"_"]
    if run_range:        
        startkey = [label, module, run_range[0]]
        endkey = [label, module, run_range[1]+1] # range inclusive    
    rows = database.view("_design/proddata/_view/%s_by_label" % (data_type),
                   startkey=startkey, endkey=endkey, reduce=False)
    for row in rows:
        if copy_type=="GUID":
            if not row["value"][1] or row["value"][1]=="":
                print "Cannot get file %s, no GUID" % (row["value"][0])
                continue
        else:
            if len(row["value"][4])==0 or row["value"][4]=="":
                print "Cannot get file %s, no SURL" % row["value"][0]
                continue
        names.append(row["value"][0])
        if copy_type=="GUID":
            guids.append(row["value"][1])
        else:
            guids.append(grid.get_closest_copy(server_list, row["value"][4]))
        adlers.append(row["value"][2])
        sizes.append(row["value"][3])
    return names, sizes, guids, adlers


def get_labels(data_type, module=None):
    """Get a list of all labels available

    Specify a module to see versions associated with that module.
    """
    labels = set()
    if module is None:
        rows = database.view("_design/proddata/_view/%s_by_label" % (data_type),
                             reduce=True, group_level=1)
        for row in rows:
            labels.add(row["key"][0])
    elif type(module)==list and len(module)==1:
        rows = database.view("_design/proddata/_view/%s_by_label" % (data_type),
                             reduce=True, group_level=2)
        for row in rows:
            if str(row["key"][1])==module[0]:
                labels.add(row["key"][0])
    else:
        raise Exception("Must only provide one module name.")
    return labels


def get_versions(data_type, module=None):
    """Get a list of all versions available.

    Specify a module to see versions associated with that module.
    """
    versions = set()
    if module is None:
        rows = database.view("_design/proddata/_view/%s_by_mod_pass_sr" % (data_type),
                             reduce=True, group_level=2)
        for row in rows:
            versions.add(row["key"][1])
    elif type(module)==list and len(module)==1:
        rows = database.view("_design/proddata/_view/%s_by_mod_pass_sr" % (data_type),
                             reduce=True, group_level=2)
        for row in rows:
            if str(row["key"][0])==module[0]:
                versions.add(row["key"][1])
    else:
        raise Exception("Must only provide one module name.")
    return versions


def get_modules(data_type, label=None, version=None):
    """Get a list of all modules available

    Only one of label or version can be specified (or neither).
    """
    if label is not None and version is not None:
        raise Exception("May only specify label OR version")
    modules = set()
    if label is not None:
        # Only modules for a given label
        rows = database.view("_design/proddata/_view/%s_by_label" % (data_type),
                             reduce=True, group_level=2, startkey=[label],
                             endkey=[label+"_"])
        for row in rows:
            modules.add(row["key"][1])
    elif version is not None:
        # Only modules for a given RAT version
        rows = database.view("_design/proddata/_view/%s_by_mod_pass_sr" % (data_type),
                             reduce=True, group_level=2)
        for row in rows:
            if str(row["key"][1])==version:
                modules.add(row["key"][0])
    else:
        # Any and all modules
        rows = database.view("_design/proddata/_view/%s_by_mod_pass_sr" % (data_type),
                             reduce=True, group_level=1)
        for row in rows:
            modules.add(row["key"][0])
    return modules


def get_response(host, url, username=None, password=None):
    headers = {}
    if username is not None and password is not None:
        auth_string = base64.encodestring('%s:%s' % (username, password))[:-1]
        headers['Authorization'] = 'Basic %s' % auth_string
    connection = httplib.HTTPConnection(host, port=5984)
    try:
        connection.request('GET', url, headers=headers)
        response = connection.getresponse()
    except httplib.HTTPException as e:
        sys.stderr.write('Error accessing the requested db query: %s' % str(e))
        sys.exit(20)
    return response.read()


def generate_list_by_label(label, data_type, module, run_range):
    """Generate the file list by production labels
    """
    names = []
    sizes = []
    guids = []
    adlers = []
    if not module:
        module = get_module_list_label(data_type)
    print module
    for i, mod in enumerate(module):
        print "Generating file lists, %d of %d" % (i, len(module))
        n, s, g, a = get_list_by_label_module(data_type, label, mod, run_range)
        names += n
        sizes += s
        guids += g
        adlers += a
    if len(names)==0:
        print "No files for label %s, modules %s" % (label, module)
        sys.exit()
    return names, sizes, guids, adlers


def generate_list_by_version(version, data_type, module, run_range):
    """Generate the file list by rat version
    """
    # Now loop through each module and get the file lists
    if not module:
        module = get_module_list_version(data_type, version)
    if len(module)==0:
        print "No modules for rat %s" % version
        sys.exit()
    names = []
    sizes = []
    guids = []
    adlers = []
    for i, mod in enumerate(module):
        print "Generating file lists, %d of %d" % (i, len(module))
        n, s, g, a= get_list_by_module_version(data_type, mod, version, run_range)
        names += n
        sizes += s
        guids += g
        adlers += a
    if len(names)==0:
        print "No files for version %s, modules %s" % (version, module)
        sys.exit()
    return names, sizes, guids, adlers


def write_output(output, names, sizes, guids, adlers):
    """Write the output file.
    """
    if len(names)==0:
       print "No files found!"
       sys.exit()
    list_file = open(output, "w")
    list_file.write("%s\n" % copy_type)
    for i, n in enumerate(names):
        list_file.write("%s\t%s\t%s\t%s\n" % (n, sizes[i], guids[i], adlers[i]))
    list_file.close()
    print "Found %d files, listed in %s" % (len(names), output)


if __name__=="__main__":
    parser = argparse.ArgumentParser(description="File list generator.  Users MUST specify either a label (-l, recommended) or rat version (-v).")
    parser.add_argument("-d", dest="db_name", help="Data-flow database name [production]",
                        default="production")
    parser.add_argument("-s", dest="db_server",
                        help="Data-flow database server [snoplus.westgrid.ca]",
                        default="snoplus.cpp.ualberta.ca")
    parser.add_argument("-p", dest="db_port",
                        help="Data-flow database server port [5984]", default=5984, type=int)
    parser.add_argument("-f", dest="full_data", help="[Ntuple] or full datasets (set option for full)",
                        action="store_true")
    parser.add_argument("-o", dest="output", help="Filename to write the list to [filelist.dat]",
                        default="filelist.dat")
    
    parser.add_argument("-m", dest="module", help="Requested module, format -m mod1 mod2 ... (blank for all)", nargs="+")
    parser.add_argument("-r", dest="run_range", help="Requested run range, format -r low high (blank for all)", type=int, nargs='+')
    
    group = parser.add_mutually_exclusive_group()
    group.add_argument("-l", dest="label", help="Requested production label (recommended)")   
    group.add_argument("-v", dest="version", help="Requested RAT version")
    
    parser.add_argument("--labels", dest="list_labels", help="Show list of possible labels", action="store_true")
    parser.add_argument("--versions", dest="list_versions", help="Show list of possible versions", action="store_true")
    parser.add_argument("--modules", dest="list_modules", help="Show list of possible modules", action="store_true")
    
    args = parser.parse_args()

    # Default is to search for ntuple files
    data_type = "ntuples"
    if args.full_data:
        data_type = "files"
    
    # First, check that no help commands are requested
    if args.list_labels:
        database.connect_db(args.db_server, args.db_port, args.db_name)
        for l in sorted(get_labels(data_type, args.module)):
            print l
        sys.exit()
    if args.list_versions:
        database.connect_db(args.db_server, args.db_port, args.db_name)
        for v in sorted(get_versions(data_type, args.module)):
            print v
        sys.exit()
    if args.list_modules:
        database.connect_db(args.db_server, args.db_port, args.db_name)
        for m in sorted(get_modules(data_type, args.label, args.version)):
            print m
        sys.exit()

    # Check that the output file is OK
    if os.path.exists(args.output):
        overwrite = raw_input("%s exists, overwrite [y/N]?: " % args.output)
        if overwrite!="y" and overwrite!="Y":
            print "Specify another filename"
            sys.exit()

    # Connect to the database
    database.connect_db(args.db_server, args.db_port, args.db_name)

    # If there is a run range, need exactly two arguments
    if args.run_range:
        if len(args.run_range)!=2:
            print "Require two arguments for run range (lower upper)"
            sys.exit()

    if grid.copy == grid.srm_copy:
        # Use SRMs to copy from 
        copy_type = "SURL"
        server_list = grid.get_server_preferences()

    # Now handle either rat version or labelled data
    if args.label:
        names, sizes, guids, adlers = generate_list_by_label(args.label, data_type, args.module, args.run_range)   
    elif args.version:
        names, sizes, guids, adlers = generate_list_by_version(args.version, data_type, args.module, args.run_range)   
    else:
        parser.print_help()
        sys.exit()    

    # And write the output file
    write_output(args.output, names, sizes, guids, adlers)
    
